<html>
    <head>
<title>Crazy Driver Sim - Urban Mayhem Racing Simulator</title>
<style>
    body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        font-family: 'Press Start 2P', cursive;
        background-color: #000;
        color: #fff;
    }
    #gameCanvas {
        width: 100%;
        height: 100%;
        image-rendering: pixelated;
    }
    #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        font-size: 16px;
    }
    #controls {
        position: absolute;
        bottom: 10px;
        left: 10px;
        font-size: 14px;
        background-color: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 5px;
    }
    #newCityBtn {
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 10px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }
    #radioControls {
        position: absolute;
        top: 60px;
        right: 10px;
        background-color: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 5px;
    }
    .radioBtn {
        display: block;
        margin: 5px 0;
        padding: 5px 10px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
    }
    #nowPlaying {
        margin-top: 10px;
        font-size: 12px;
    }
    #gameOverScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 24px;
        color: white;
        display: none;
    }
    #restartBtn {
        margin-top: 20px;
        padding: 10px 20px;
        font-size: 18px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }
    #gameTitle {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 24px;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
</style>
</head>
<body>
<div id="gameTitle">Crazy Driver Sim</div>
<canvas id="gameCanvas"></canvas>
<div id="ui">
    <div>Speed: <span id="speedometer">0</span> km/h</div>
    <div>Score: <span id="score">0</span></div>
    <div>Wanted Level: <span id="wantedLevel">0</span></div>
</div>
<div id="controls">
    Controls:<br>
    Arrow keys to steer<br>
    Up to accelerate<br>
    Down to brake
</div>
<button id="newCityBtn">Generate New City</button>
<div id="radioControls">
    <button id="prevChannel" class="radioBtn">Previous Channel</button>
    <button id="nextChannel" class="radioBtn">Next Channel</button>
    <button id="stopRadio" class="radioBtn">Stop Radio</button>
    <div id="nowPlaying"></div>
</div>
<div id="gameOverScreen">
    <h1>Game Over</h1>
    <p>Your Score: <span id="finalScore"></span></p>
    <button id="restartBtn">Restart</button>
</div>


<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const speedometer = document.getElementById('speedometer');
const scoreElement = document.getElementById('score');
const wantedLevelElement = document.getElementById('wantedLevel');
const newCityBtn = document.getElementById('newCityBtn');
const nowPlaying = document.getElementById('nowPlaying');
const gameOverScreen = document.getElementById('gameOverScreen');
const finalScoreElement = document.getElementById('finalScore');
const restartBtn = document.getElementById('restartBtn');

let city = [];
let buildings = [];
let trees = [];
let pedestrians = [];
let bloodSplashes = [];
let policeCars = [];
const trackWidth = 80;
const sidewalkWidth = 20;
const trackSegments = 8;
const minSegmentLength = 200;
const maxSegmentLength = 400;
const citySize = 4; // 4x4 grid of tracks
const maxPedestrians = 40;
const numPoliceCars = 5;

let playerX = 0;
let playerY = 0;
let playerAngle = 0;
let playerSpeed = 0;
let currentTrack = 0;
let currentSegment = 0;
let score = 0;
let wantedLevel = 0;
let gameOver = false;

const keys = {};

// Radio stations
const radioStations = [
    { name: "Chaos FM", url: "https://streaming.radio.co/s5c5da6a36/listen" },
    { name: "Mayhem Beats", url: "https://radio.plaza.one/mp3" },
    { name: "Crazy Tunes", url: "https://streams.ilovemusic.de/iloveradio17.mp3" },
    { name: "Smooth Criminal", url: "https://streaming.radio.co/s3928a1fef/listen" },
    { name: "Getaway Rock", url: "https://streaming.radio.co/s5c5da6a36/listen" }
];

let currentRadio = null;
let currentChannel = -1;

document.addEventListener('keydown', (e) => {
    keys[e.code] = true;
});

document.addEventListener('keyup', (e) => {
    keys[e.code] = false;
});

newCityBtn.addEventListener('click', generateCity);
restartBtn.addEventListener('click', restartGame);

// Radio controls
document.getElementById('prevChannel').addEventListener('click', () => changeChannel(-1));
document.getElementById('nextChannel').addEventListener('click', () => changeChannel(1));
document.getElementById('stopRadio').addEventListener('click', stopRadio);

function changeChannel(direction) {
    currentChannel = (currentChannel + direction + radioStations.length) % radioStations.length;
    playRadio(currentChannel);
}

function playRadio(index) {
    if (currentRadio) {
        currentRadio.pause();
    }
    currentRadio = new Audio(radioStations[index].url);
    currentRadio.play();
    nowPlaying.textContent = `Now playing: ${radioStations[index].name}`;
}

function stopRadio() {
    if (currentRadio) {
        currentRadio.pause();
        currentRadio = null;
        nowPlaying.textContent = '';
        currentChannel = -1;
    }
}

function generateTrack(startX, startY, endX, endY) {
    let track = [{x: startX, y: startY}];
    let currentX = startX;
    let currentY = startY;
    const dx = endX - startX;
    const dy = endY - startY;
    const angle = Math.atan2(dy, dx);
    const length = Math.sqrt(dx*dx + dy*dy);
    const segmentLength = length / (trackSegments - 1);

    for (let i = 1; i < trackSegments - 1; i++) {
        const progress = i / (trackSegments - 1);
        const noise = (Math.random() - 0.5) * segmentLength * 0.5;
        currentX = startX + Math.cos(angle) * segmentLength * i + Math.cos(angle + Math.PI/2) * noise;
        currentY = startY + Math.sin(angle) * segmentLength * i + Math.sin(angle + Math.PI/2) * noise;
        track.push({x: currentX, y: currentY});
    }
    track.push({x: endX, y: endY});
    return track;
}

function generateBuildings() {
    buildings = [];
    const gridSize = 2000;
    for (let i = 0; i < citySize; i++) {
        for (let j = 0; j < citySize; j++) {
            const x = i * gridSize + trackWidth + sidewalkWidth;
            const y = j * gridSize + trackWidth + sidewalkWidth;
            const maxWidth = gridSize - 2 * (trackWidth + sidewalkWidth);
            const maxHeight = gridSize - 2 * (trackWidth + sidewalkWidth);

            // Generate 5-10 buildings per block
            const buildingCount = Math.floor(Math.random() * 6) + 5;
            for (let k = 0; k < buildingCount; k++) {
                const buildingWidth = Math.random() * (maxWidth / 4) + maxWidth / 8;
                const buildingHeight = Math.random() * (maxHeight / 4) + maxHeight / 8;
                const buildingX = x + Math.random() * (maxWidth - buildingWidth);
                const buildingY = y + Math.random() * (maxHeight - buildingHeight);
                const buildingColor = `rgb(${Math.random()*50+100}, ${Math.random()*50+100}, ${Math.random()*50+100})`;
                const floors = Math.floor(Math.random() * 5) + 3;
                buildings.push({
                    x: buildingX,
                    y: buildingY,
                    width: buildingWidth,
                    height: buildingHeight,
                    color: buildingColor,
                    floors: floors,
                    windows: generateWindows(floors)
                });
            }
        }
    }
}

function generateTrees() {
    trees = [];
    const gridSize = 2000;
    for (let i = 0; i < citySize; i++) {
        for (let j = 0; j < citySize; j++) {
            const x = i * gridSize + trackWidth + sidewalkWidth;
            const y = j * gridSize + trackWidth + sidewalkWidth;
            const maxWidth = gridSize - 2 * (trackWidth + sidewalkWidth);
            const maxHeight = gridSize - 2 * (trackWidth + sidewalkWidth);

            // Generate 10-20 trees per block
            const treeCount = Math.floor(Math.random() * 11) + 10;
            for (let k = 0; k < treeCount; k++) {
                const treeX = x + Math.random() * maxWidth;
                const treeY = y + Math.random() * maxHeight;
                const treeSize = Math.random() * 30 + 20;
                trees.push({
                    x: treeX,
                    y: treeY,
                    size: treeSize
                });
            }
        }
    }
}


function generatePedestrians() {
    pedestrians = [];
    const gridSize = 2000;
    const totalArea = citySize * citySize * gridSize * gridSize;
    const pedestrianCount = Math.min(maxPedestrians, Math.floor(totalArea / 100000));

    for (let i = 0; i < pedestrianCount; i++) {
        const trackIndex = Math.floor(Math.random() * city.length);
        const track = city[trackIndex];
        const segmentIndex = Math.floor(Math.random() * (track.length - 1));
        const start = track[segmentIndex];
        const end = track[segmentIndex + 1];
        const progress = Math.random();
        const x = start.x + (end.x - start.x) * progress;
        const y = start.y + (end.y - start.y) * progress;
        const angle = Math.atan2(end.y - start.y, end.x - start.x);
        const side = Math.random() < 0.5 ? 1 : -1;
        
        pedestrians.push({
            x: x + Math.cos(angle + Math.PI/2) * (trackWidth/2 + sidewalkWidth/2) * side,
            y: y + Math.sin(angle + Math.PI/2) * (trackWidth/2 + sidewalkWidth/2) * side,
            angle: angle,
            speed: Math.random() * 0.5 + 0.5,
            trackIndex: trackIndex,
            segmentIndex: segmentIndex,
            progress: progress,
            side: side
        });
    }
}

function generatePoliceCars() {
    policeCars = [];
    for (let i = 0; i < numPoliceCars; i++) {
        const trackIndex = Math.floor(Math.random() * city.length);
        const track = city[trackIndex];
        const segmentIndex = Math.floor(Math.random() * (track.length - 1));
        const start = track[segmentIndex];
        const end = track[segmentIndex + 1];
        const progress = Math.random();
        const x = start.x + (end.x - start.x) * progress;
        const y = start.y + (end.y - start.y) * progress;
        const angle = Math.atan2(end.y - start.y, end.x - start.x);
        
        policeCars.push({
            x: x,
            y: y,
            angle: angle,
            speed: 0,
            trackIndex: trackIndex,
            segmentIndex: segmentIndex,
            progress: progress,
            chasing: false
        });
    }
}

function generateWindows(floors) {
    const windows = [];
    for (let floor = 0; floor < floors; floor++) {
        for (let window = 0; window < 4; window++) {
            windows.push(Math.random() > 0.3);  // 70% chance of a lit window
        }
    }
    return windows;
}

function generateCity() {
    city = [];
    const gridSize = 2000;
    for (let i = 0; i < citySize; i++) {
        for (let j = 0; j < citySize; j++) {
            const startX = i * gridSize;
            const startY = j * gridSize;
            // Horizontal track
            city.push(generateTrack(startX, startY, (i+1) * gridSize, startY));
            // Vertical track
            city.push(generateTrack(startX, startY, startX, (j+1) * gridSize));
        }
    }
    
    generateBuildings();
    generateTrees();
    generatePedestrians();
    generatePoliceCars();
    
    // Reset player position and score
    playerX = 0;
    playerY = 0;
    playerAngle = 0;
    playerSpeed = 0;
    currentTrack = 0;
    currentSegment = 0;
    score = 0;
    wantedLevel = 0;
    scoreElement.textContent = score;
    wantedLevelElement.textContent = wantedLevel;
    bloodSplashes = [];
    gameOver = false;
    gameOverScreen.style.display = 'none';
}

function drawBackground() {
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, "#2ecc71");
    gradient.addColorStop(1, "#27ae60");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function drawCity() {
    city.forEach(track => {
        ctx.beginPath();
        ctx.moveTo(track[0].x, track[0].y);
        for (let i = 1; i < track.length; i++) {
            ctx.lineTo(track[i].x, track[i].y);
        }
        ctx.strokeStyle = "#555";
        ctx.lineWidth = trackWidth;
        ctx.stroke();

        // Draw sidewalks
        ctx.beginPath();
        ctx.moveTo(track[0].x, track[0].y);
        for (let i = 1; i < track.length; i++) {
            ctx.lineTo(track[i].x, track[i].y);
        }
        ctx.strokeStyle = "#999";
        ctx.lineWidth = trackWidth + sidewalkWidth * 2;
        ctx.stroke();

        // Draw road markings
        ctx.strokeStyle = "#FFF";
        ctx.lineWidth = 2;
        ctx.setLineDash([20, 20]);
        ctx.stroke();
        ctx.setLineDash([]);
    });
}

function drawBuildings() {
    buildings.forEach(building => {
        ctx.fillStyle = building.color;
        ctx.fillRect(building.x, building.y, building.width, building.height);
        
        // Windows
        const floorHeight = building.height / building.floors;
        const windowWidth = building.width / 5;
        ctx.fillStyle = "rgba(255, 255, 0, 0.5)";
        for (let floor = 0; floor < building.floors; floor++) {
            for (let window = 0; window < 4; window++) {
                if (building.windows[floor * 4 + window]) {
                    ctx.fillRect(
                        building.x + (window + 1) * windowWidth,
                        building.y + floor * floorHeight + floorHeight / 4,
                        windowWidth / 2,
                        floorHeight / 2
                    );
                }
            }
        }
    });
}

function drawTrees() {
    trees.forEach(tree => {
        // Draw trunk
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(tree.x - tree.size/8, tree.y - tree.size/2, tree.size/4, tree.size/2);
        
        // Draw foliage
        ctx.beginPath();
        ctx.moveTo(tree.x, tree.y - tree.size);
        ctx.lineTo(tree.x + tree.size/2, tree.y - tree.size/2);
        ctx.lineTo(tree.x - tree.size/2, tree.y - tree.size/2);
        ctx.closePath();
        ctx.fillStyle = "#228B22";
        ctx.fill();
    });
}

function drawPedestrians() {
    ctx.fillStyle = "#F4A460";
    pedestrians.forEach(ped => {
        ctx.beginPath();
        ctx.arc(ped.x, ped.y, 5, 0, Math.PI * 2);
        ctx.fill();
    });
}

function drawPlayer() {
    ctx.save();
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.rotate(playerAngle);
    ctx.fillStyle = "red";
    ctx.fillRect(-15, -7.5, 30, 15);
    ctx.restore();
}

function drawPoliceCars() {
    policeCars.forEach(car => {
        ctx.save();
        ctx.translate(car.x, car.y);
        ctx.rotate(car.angle);
        ctx.fillStyle = "blue";
        ctx.fillRect(-15, -7.5, 30, 15);
        
        // Draw police lights
        const lightSize = 5;
        ctx.fillStyle = (Date.now() % 1000 < 500) ? "red" : "blue";
        ctx.fillRect(-10, -7.5 - lightSize, lightSize, lightSize);
        ctx.fillRect(10 - lightSize, -7.5 - lightSize, lightSize, lightSize);
        
        ctx.restore();
    });
}

function drawBloodSplashes() {
    ctx.fillStyle = "#8B0000";
    bloodSplashes.forEach(splash => {
        ctx.beginPath();
        ctx.arc(splash.x, splash.y, splash.size, 0, Math.PI * 2);
        ctx.fill();
    });
}

function distanceToTrack(x, y, track) {
    let minDist = Infinity;
    for (let i = 0; i < track.length - 1; i++) {
        const start = track[i];
        const end = track[i + 1];
        const progress = getSegmentProgress(x, y, start, end);
        const pos = getTrackPosition(start, end, progress);
        const dist = Math.sqrt((x - pos.x)**2 + (y - pos.y)**2);
        minDist = Math.min(minDist, dist);
    }
    return minDist;
}

function getSegmentProgress(x, y, start, end) {
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const segmentLength = Math.sqrt(dx*dx + dy*dy);
    const playerDx = x - start.x;
    const playerDy = y - start.y;
    const dotProduct = playerDx*dx + playerDy*dy;
    return Math.max(0, Math.min(1, dotProduct / (segmentLength*segmentLength)));
}

function getTrackPosition(start, end, progress) {
    return {
        x: start.x + (end.x - start.x) * progress,
        y: start.y + (end.y - start.y) * progress
    };
}

function updatePoliceCars() {
    policeCars.forEach(car => {
        const track = city[car.trackIndex];
        const start = track[car.segmentIndex];
        const end = track[car.segmentIndex + 1];
        
        if (car.chasing) {
            // Chase the player
            const dx = playerX - car.x;
            const dy = playerY - car.y;
            const distanceToPlayer = Math.sqrt(dx*dx + dy*dy);
            
            if (distanceToPlayer > 20) {
                car.angle = Math.atan2(dy, dx);
                car.speed = Math.min(car.speed + 0.1, 8);
            } else {
                car.speed *= 0.95;
            }
            
            car.x += Math.cos(car.angle) * car.speed;
            car.y += Math.sin(car.angle) * car.speed;
            
            // Check if police caught the player
            if (distanceToPlayer < 30) {
                endGame();
            }
        } else {
            // Normal patrol behavior
            car.progress += 0.005;
            if (car.progress >= 1) {
                car.segmentIndex++;
                car.progress = 0;
                if (car.segmentIndex >= track.length - 1) {
                    car.segmentIndex = 0;
                }
            }
            
            car.x = start.x + (end.x - start.x) * car.progress;
            car.y = start.y + (end.y - start.y) * car.progress;
            car.angle = Math.atan2(end.y - start.y, end.x - start.x);
            
            // Check if player is nearby
            const dx = playerX - car.x;
            const dy = playerY - car.y;
            const distanceToPlayer = Math.sqrt(dx*dx + dy*dy);
            
            if (distanceToPlayer < 300 && wantedLevel > 0) {
                car.chasing = true;
            }
        }
    });
}

function update() {
    if (gameOver) return;

    if (keys['ArrowLeft']) {
        playerAngle -= 0.05;
    }
    if (keys['ArrowRight']) {
        playerAngle += 0.05;
    }
    if (keys['ArrowUp']) {
        playerSpeed = Math.min(playerSpeed + 0.2, 10);
    } else if (keys['ArrowDown']) {
        playerSpeed = Math.max(playerSpeed - 0.4, 0);
    } else {
        playerSpeed *= 0.98;
    }

    const newX = playerX + Math.cos(playerAngle) * playerSpeed;
    const newY = playerY + Math.sin(playerAngle) * playerSpeed;

    // Check for collision with any track
    let onTrack = false;
    for (let i = 0; i < city.length; i++) {
        if (distanceToTrack(newX, newY, city[i]) <= trackWidth / 2) {
            onTrack = true;
            currentTrack = i;
            break;
        }
    }

    if (onTrack) {
        playerX = newX;
        playerY = newY;
    } else {
        playerSpeed *= 0.5; // Slow down on collision
    }

    // Update pedestrians
    pedestrians.forEach((ped, index) => {
        const track = city[ped.trackIndex];
        const start = track[ped.segmentIndex];
        const end = track[ped.segmentIndex + 1];
        ped.progress += ped.speed / Math.sqrt((end.x - start.x)**2 + (end.y - start.y)**2);

        if (ped.progress >= 1) {
            ped.segmentIndex++;
            ped.progress = 0;
            if (ped.segmentIndex >= track.length - 1) {
                ped.segmentIndex = 0;
            }
        }

        const newStart = track[ped.segmentIndex];
        const newEnd = track[ped.segmentIndex + 1];
        ped.x = newStart.x + (newEnd.x - newStart.x) * ped.progress;
        ped.y = newStart.y + (newEnd.y - newStart.y) * ped.progress;
        ped.angle = Math.atan2(newEnd.y - newStart.y, newEnd.x - newStart.x);

        // Offset pedestrian to sidewalk
        ped.x += Math.cos(ped.angle + Math.PI/2) * (trackWidth/2 + sidewalkWidth/2) * ped.side;
        ped.y += Math.sin(ped.angle + Math.PI/2) * (trackWidth/2 + sidewalkWidth/2) * ped.side;

        // Check for collision with player
        const dx = ped.x - playerX;
        const dy = ped.y - playerY;
        const distance = Math.sqrt(dx*dx + dy*dy);
        if (distance < 20) {  // If player hits pedestrian
            score++;
            wantedLevel++;
            scoreElement.textContent = score;
            wantedLevelElement.textContent = wantedLevel;
            // Create blood splash
            bloodSplashes.push({
                x: ped.x,
                y: ped.y,
                size: Math.random() * 5 + 5
            });
            // Respawn pedestrian at a random location
            const newTrackIndex = Math.floor(Math.random() * city.length);
            const newTrack = city[newTrackIndex];
            ped.trackIndex = newTrackIndex;
            ped.segmentIndex = Math.floor(Math.random() * (newTrack.length - 1));
            ped.progress = 0;
            ped.side = Math.random() < 0.5 ? 1 : -1;
        }
    });

    updatePoliceCars();

    speedometer.textContent = Math.round(playerSpeed * 10);
}

function endGame() {
    gameOver = true;
    finalScoreElement.textContent = score;
    gameOverScreen.style.display = 'flex';
}

function restartGame() {
    generateCity();
    gameLoop();
}

function gameLoop() {
    if (gameOver) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawBackground();
    
    ctx.save();
    ctx.translate(canvas.width/2 - playerX, canvas.height/2 - playerY);
    drawTrees();
    drawBuildings();
    drawCity();
    drawPedestrians();
    drawBloodSplashes();
    drawPoliceCars();
    ctx.restore();
    
    drawPlayer();
    
    update();
    
    requestAnimationFrame(gameLoop);
}

generateCity();
gameLoop();
</script>

</body></html>