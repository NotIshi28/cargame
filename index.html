<html>
    <head>
<title>Crazy Driver Sim - Urban Mayhem Racing Simulator</title>
<style>
    body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        font-family: 'Press Start 2P', cursive;
        background-color: #000;
        color: #fff;
    }
    #gameCanvas {
        width: 100%;
        height: 100%;
        image-rendering: pixelated;
    }
    #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        font-size: 16px;
    }
    #controls {
        position: absolute;
        bottom: 10px;
        left: 10px;
        font-size: 14px;
        background-color: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 5px;
    }
    #newCityBtn {
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 10px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }
    #radioControls {
        position: absolute;
        top: 60px;
        right: 10px;
        background-color: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 5px;
    }
    .radioBtn {
        display: block;
        margin: 5px 0;
        padding: 5px 10px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
    }
    #nowPlaying {
        margin-top: 10px;
        font-size: 12px;
    }
    #gameOverScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 24px;
        color: white;
        display: none;
    }
    #restartBtn {
        margin-top: 20px;
        padding: 10px 20px;
        font-size: 18px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }
    #gameTitle {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 24px;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
</style>
</head>
<body>
<div id="gameTitle">Crazy Driver Sim</div>
<canvas id="gameCanvas"></canvas>
<div id="ui">
    <div>Speed: <span id="speedometer">0</span> km/h</div>
    <div>Score: <span id="score">0</span></div>
    <div>Wanted Level: <span id="wantedLevel">0</span></div>
</div>
<div id="controls">
    Controls:<br>
    Arrow keys to steer<br>
    Up to accelerate<br>
    Down to brake
</div>
<button id="newCityBtn">Generate New City</button>
<div id="radioControls">
    <button id="prevChannel" class="radioBtn">Previous Channel</button>
    <button id="nextChannel" class="radioBtn">Next Channel</button>
    <button id="stopRadio" class="radioBtn">Stop Radio</button>
    <div id="nowPlaying"></div>
</div>
<div id="gameOverScreen">
    <h1>Game Over</h1>
    <p>Your Score: <span id="finalScore"></span></p>
    <button id="restartBtn">Restart</button>
</div>


<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const speedometer = document.getElementById('speedometer');
const scoreElement = document.getElementById('score');
const wantedLevelElement = document.getElementById('wantedLevel');
const newCityBtn = document.getElementById('newCityBtn');
const nowPlaying = document.getElementById('nowPlaying');
const gameOverScreen = document.getElementById('gameOverScreen');
const finalScoreElement = document.getElementById('finalScore');
const restartBtn = document.getElementById('restartBtn');

let city = [];
let buildings = [];
let trees = [];
let pedestrians = [];
let bloodSplashes = [];
let policeCars = [];
const trackWidth = 80;
const sidewalkWidth = 20;
const trackSegments = 8;
const minSegmentLength = 200;
const maxSegmentLength = 400;
const citySize = 4; // 4x4 grid of tracks
const maxPedestrians = 40;
const numPoliceCars = 5;

let playerX = 0;
let playerY = 0;
let playerAngle = 0;
let playerSpeed = 0;
let currentTrack = 0;
let currentSegment = 0;
let score = 0;
let wantedLevel = 0;
let gameOver = false;

const keys = {};

// Radio stations
const radioStations = [
    { name: "Chaos FM", url: "https://streaming.radio.co/s5c5da6a36/listen" },
    { name: "Mayhem Beats", url: "https://radio.plaza.one/mp3" },
    { name: "Crazy Tunes", url: "https://streams.ilovemusic.de/iloveradio17.mp3" },
    { name: "Smooth Criminal", url: "https://streaming.radio.co/s3928a1fef/listen" },
    { name: "Getaway Rock", url: "https://streaming.radio.co/s5c5da6a36/listen" }
];

let currentRadio = null;
let currentChannel = -1;

document.addEventListener('keydown', (e) => {
    keys[e.code] = true;
});

document.addEventListener('keyup', (e) => {
    keys[e.code] = false;
});

newCityBtn.addEventListener('click', generateCity);
restartBtn.addEventListener('click', restartGame);

// Radio controls
document.getElementById('prevChannel').addEventListener('click', () => changeChannel(-1));
document.getElementById('nextChannel').addEventListener('click', () => changeChannel(1));
document.getElementById('stopRadio').addEventListener('click', stopRadio);

function changeChannel(direction) {
    currentChannel = (currentChannel + direction + radioStations.length) % radioStations.length;
    playRadio(currentChannel);
}

function playRadio(index) {
    if (currentRadio) {
        currentRadio.pause();
    }
    currentRadio = new Audio(radioStations[index].url);
    currentRadio.play();
    nowPlaying.textContent = `Now playing: ${radioStations[index].name}`;
}

function stopRadio() {
    if (currentRadio) {
        currentRadio.pause();
        currentRadio = null;
        nowPlaying.textContent = '';
        currentChannel = -1;
    }
}

function generateTrack(startX, startY, endX, endY) {
    let track = [{x: startX, y: startY}];
    let currentX = startX;
    let currentY = startY;
    const dx = endX - startX;
    const dy = endY - startY;
    const angle = Math.atan2(dy, dx);
    const length = Math.sqrt(dx*dx + dy*dy);
    const segmentLength = length / (trackSegments - 1);

    for (let i = 1; i < trackSegments - 1; i++) {
        const progress = i / (trackSegments - 1);
        const noise = (Math.random() - 0.5) * segmentLength * 0.5;
        currentX = startX + Math.cos(angle) * segmentLength * i + Math.cos(angle + Math.PI/2) * noise;
        currentY = startY + Math.sin(angle) * segmentLength * i + Math.sin(angle + Math.PI/2) * noise;
        track.push({x: currentX, y: currentY});
    }
    track.push({x: endX, y: endY});
    return track;
}

function generateBuildings() {
    buildings = [];
    const gridSize = 2000;
    for (let i = 0; i < citySize; i++) {
        for (let j = 0; j < citySize; j++) {
            const x = i * gridSize + trackWidth + sidewalkWidth;
            const y = j * gridSize + trackWidth + sidewalkWidth;
            const maxWidth = gridSize - 2 * (trackWidth + sidewalkWidth);
            const maxHeight = gridSize - 2 * (trackWidth + sidewalkWidth);

            // Generate 5-10 buildings per block
            const buildingCount = Math.floor(Math.random() * 6) + 5;
            for (let k = 0; k < buildingCount; k++) {
                const buildingWidth = Math.random() * (maxWidth / 4) + maxWidth / 8;
                const buildingHeight = Math.random() * (maxHeight / 4) + maxHeight / 8;
                const buildingX = x + Math.random() * (maxWidth - buildingWidth);
                const buildingY = y + Math.random() * (maxHeight - buildingHeight);
                const buildingColor = `rgb(${Math.random()*50+100}, ${Math.random()*50+100}, ${Math.random()*50+100})`;
                const floors = Math.floor(Math.random() * 5) + 3;
                buildings.push({
                    x: buildingX,
                    y: buildingY,
                    width: buildingWidth,
                    height: buildingHeight,
                    color: buildingColor,
                    floors: floors,
                    windows: generateWindows(floors)
                });
            }
        }
    }
}

function generateTrees() {
    trees = [];
    const gridSize = 2000;
    for (let i = 0; i < citySize; i++) {
        for (let j = 0; j < citySize; j++) {
            const x = i * gridSize + trackWidth + sidewalkWidth;
            const y = j * gridSize + trackWidth + sidewalkWidth;
            const maxWidth = gridSize - 2 * (trackWidth + sidewalkWidth);
            const maxHeight = gridSize - 2 * (trackWidth + sidewalkWidth);

            // Generate 10-20 trees per block
            const treeCount = Math.floor(Math.random() * 11) + 10;
            for (let k = 0; k < treeCount; k++) {
                const treeX = x + Math.random() * maxWidth;
                const treeY = y + Math.random() * maxHeight;
                const treeSize = Math.random() * 30 + 20;
                trees.push({
                    x: treeX,
                    y: treeY,
                    size: treeSize
                });
            }
        }
    }
}


function generatePedestrians() {
    pedestrians = [];
    const gridSize = 2000;
    const totalArea = citySize * citySize * gridSize * gridSize;
    const pedestrianCount = Math.min(maxPedestrians, Math.floor(totalArea / 100000));

    for (let i = 0; i < pedestrianCount; i++) {
        const trackIndex = Math.floor(Math.random() * city.length);
        const track = city[trackIndex];
        const segmentIndex = Math.floor(Math.random() * (track.length - 1));
        const start = track[segmentIndex];
        const end = track[segmentIndex + 1];
        const progress = Math.random();
        const x = start.x + (end.x - start.x) * progress;
        const y = start.y + (end.y - start.y) * progress;
        const angle = Math.atan2(end.y - start.y, end.x - start.x);
        const side = Math.random() < 0.5 ? 1 : -1;
        
        pedestrians.push({
            x: x + Math.cos(angle + Math.PI/2) * (trackWidth/2 + sidewalkWidth/2) * side,
            y: y + Math.sin(angle + Math.PI/2) * (trackWidth/2 + sidewalkWidth/2) * side,
            angle: angle,
            speed: Math.random() * 0.5 + 0.5,
            trackIndex: trackIndex,
            segmentIndex: segmentIndex,
            progress: progress,
            side: side
        });
    }
}

function generatePoliceCars() {
    policeCars = [];
    for (let i = 0; i < numPoliceCars; i++) {
        const trackIndex = Math.floor(Math.random() * city.length);
        const track = city[trackIndex];
        const segmentIndex = Math.floor(Math.random() * (track.length - 1));
        const start = track[segmentIndex];
        const end = track[segmentIndex + 1];
        const progress = Math.random();
        const x = start.x + (end.x - start.x) * progress;
        const y = start.y + (end.y - start.y) * progress;
        const angle = Math.atan2(end.y - start.y, end.x - start.x);
        
        policeCars.push({
            x: x,
            y: y,
            angle: angle,
            speed: 0,
            trackIndex: trackIndex,
            segmentIndex: segmentIndex,
            progress: progress,
            chasing: false
        });
    }
}

function generateWindows(floors) {
    const windows = [];
    for (let floor = 0; floor < floors; floor++) {
        for (let window = 0; window < 4; window++) {
            windows.push(Math.random() > 0.3);  // 70% chance of a lit window
        }
    }
    return windows;
}

function generateCity() {
    city = [];
    const gridSize = 2000;
    for (let i = 0; i < citySize; i++) {
        for (let j = 0; j < citySize; j++) {
            const startX = i * gridSize;
            const startY = j * gridSize;
            // Horizontal track
            city.push(generateTrack(startX, startY, (i+1) * gridSize, startY));
            // Vertical track
            city.push(generateTrack(startX, startY, startX, (j+1) * gridSize));
        }
    }
    
    generateBuildings();
    generateTrees();
    generatePedestrians();
    generatePoliceCars();
    
    // Reset player position and score
    playerX = 0;
    playerY = 0;
    playerAngle = 0;
    playerSpeed = 0;
    currentTrack = 0;
    currentSegment = 0;
    score = 0;
    wantedLevel = 0;
    scoreElement.textContent = score;
    wantedLevelElement.textContent = wantedLevel;
    bloodSplashes = [];
    gameOver = false;
    gameOverScreen.style.display = 'none';
}

function drawBackground() {
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, "#2ecc71");
    gradient.addColorStop(1, "#27ae60");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

</script>

</body></html>